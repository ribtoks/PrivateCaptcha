// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cache.sql

package generated

import (
	"context"

	"time"
)

const createCache = `-- name: CreateCache :exec
INSERT INTO backend.cache (key, value, expires_at) VALUES ($1, $2, NOW() + $3::INTERVAL)
ON CONFLICT (key) DO UPDATE 
SET value = EXCLUDED.value, expires_at = EXCLUDED.expires_at
`

type CreateCacheParams struct {
	Key     string        `db:"key" json:"key"`
	Value   []byte        `db:"value" json:"value"`
	Column3 time.Duration `db:"column_3" json:"column_3"`
}

func (q *Queries) CreateCache(ctx context.Context, arg *CreateCacheParams) error {
	_, err := q.db.Exec(ctx, createCache, arg.Key, arg.Value, arg.Column3)
	return err
}

const createCacheMany = `-- name: CreateCacheMany :exec
INSERT INTO backend.cache (key, value, expires_at)
SELECT unnest($1::TEXT[]) as key,
       unnest($2::BYTEA[]) as value,
       NOW() + unnest($3::INTERVAL[]) as expires_at
ON CONFLICT (key)
DO UPDATE SET
    value = EXCLUDED.value,
    expires_at = EXCLUDED.expires_at
`

type CreateCacheManyParams struct {
	Keys      []string        `db:"keys" json:"keys"`
	Values    [][]byte        `db:"values" json:"values"`
	Intervals []time.Duration `db:"intervals" json:"intervals"`
}

func (q *Queries) CreateCacheMany(ctx context.Context, arg *CreateCacheManyParams) error {
	_, err := q.db.Exec(ctx, createCacheMany, arg.Keys, arg.Values, arg.Intervals)
	return err
}

const deleteCachedByKey = `-- name: DeleteCachedByKey :exec
DELETE FROM backend.cache WHERE key = $1
`

func (q *Queries) DeleteCachedByKey(ctx context.Context, key string) error {
	_, err := q.db.Exec(ctx, deleteCachedByKey, key)
	return err
}

const deleteExpiredCache = `-- name: DeleteExpiredCache :exec
DELETE FROM backend.cache WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredCache(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredCache)
	return err
}

const getCachedByKey = `-- name: GetCachedByKey :one
SELECT value FROM backend.cache WHERE key = $1 AND expires_at >= NOW()
`

func (q *Queries) GetCachedByKey(ctx context.Context, key string) ([]byte, error) {
	row := q.db.QueryRow(ctx, getCachedByKey, key)
	var value []byte
	err := row.Scan(&value)
	return value, err
}

const updateCacheExpiration = `-- name: UpdateCacheExpiration :exec
UPDATE backend.cache SET expires_at = NOW() + $2::INTERVAL WHERE key = $1
`

type UpdateCacheExpirationParams struct {
	Key     string        `db:"key" json:"key"`
	Column2 time.Duration `db:"column_2" json:"column_2"`
}

func (q *Queries) UpdateCacheExpiration(ctx context.Context, arg *UpdateCacheExpirationParams) error {
	_, err := q.db.Exec(ctx, updateCacheExpiration, arg.Key, arg.Column2)
	return err
}
