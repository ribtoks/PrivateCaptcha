// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: subscriptions.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO backend.subscriptions (external_product_id, external_price_id, external_subscription_id, external_customer_id, status, source, trial_ends_at, next_billed_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id, external_product_id, external_price_id, external_subscription_id, external_customer_id, status, source, trial_ends_at, next_billed_at, cancel_from, created_at, updated_at
`

type CreateSubscriptionParams struct {
	ExternalProductID      string             `db:"external_product_id" json:"external_product_id"`
	ExternalPriceID        string             `db:"external_price_id" json:"external_price_id"`
	ExternalSubscriptionID pgtype.Text        `db:"external_subscription_id" json:"external_subscription_id"`
	ExternalCustomerID     pgtype.Text        `db:"external_customer_id" json:"external_customer_id"`
	Status                 string             `db:"status" json:"status"`
	Source                 SubscriptionSource `db:"source" json:"source"`
	TrialEndsAt            pgtype.Timestamptz `db:"trial_ends_at" json:"trial_ends_at"`
	NextBilledAt           pgtype.Timestamptz `db:"next_billed_at" json:"next_billed_at"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg *CreateSubscriptionParams) (*Subscription, error) {
	row := q.db.QueryRow(ctx, createSubscription,
		arg.ExternalProductID,
		arg.ExternalPriceID,
		arg.ExternalSubscriptionID,
		arg.ExternalCustomerID,
		arg.Status,
		arg.Source,
		arg.TrialEndsAt,
		arg.NextBilledAt,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.ExternalProductID,
		&i.ExternalPriceID,
		&i.ExternalSubscriptionID,
		&i.ExternalCustomerID,
		&i.Status,
		&i.Source,
		&i.TrialEndsAt,
		&i.NextBilledAt,
		&i.CancelFrom,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getSubscriptionByID = `-- name: GetSubscriptionByID :one
SELECT id, external_product_id, external_price_id, external_subscription_id, external_customer_id, status, source, trial_ends_at, next_billed_at, cancel_from, created_at, updated_at FROM backend.subscriptions WHERE id = $1
`

func (q *Queries) GetSubscriptionByID(ctx context.Context, id int32) (*Subscription, error) {
	row := q.db.QueryRow(ctx, getSubscriptionByID, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.ExternalProductID,
		&i.ExternalPriceID,
		&i.ExternalSubscriptionID,
		&i.ExternalCustomerID,
		&i.Status,
		&i.Source,
		&i.TrialEndsAt,
		&i.NextBilledAt,
		&i.CancelFrom,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getSubscriptionsByUserIDs = `-- name: GetSubscriptionsByUserIDs :many
SELECT s.id, s.external_product_id, s.external_price_id, s.external_subscription_id, s.external_customer_id, s.status, s.source, s.trial_ends_at, s.next_billed_at, s.cancel_from, s.created_at, s.updated_at, u.id AS user_id
FROM backend.subscriptions s
JOIN backend.users u on u.subscription_id = s.id
WHERE u.id = ANY($1::INT[]) AND u.subscription_id IS NOT NULL
`

type GetSubscriptionsByUserIDsRow struct {
	Subscription Subscription `db:"subscription" json:"subscription"`
	UserID       int32        `db:"user_id" json:"user_id"`
}

func (q *Queries) GetSubscriptionsByUserIDs(ctx context.Context, dollar_1 []int32) ([]*GetSubscriptionsByUserIDsRow, error) {
	rows, err := q.db.Query(ctx, getSubscriptionsByUserIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetSubscriptionsByUserIDsRow
	for rows.Next() {
		var i GetSubscriptionsByUserIDsRow
		if err := rows.Scan(
			&i.Subscription.ID,
			&i.Subscription.ExternalProductID,
			&i.Subscription.ExternalPriceID,
			&i.Subscription.ExternalSubscriptionID,
			&i.Subscription.ExternalCustomerID,
			&i.Subscription.Status,
			&i.Subscription.Source,
			&i.Subscription.TrialEndsAt,
			&i.Subscription.NextBilledAt,
			&i.Subscription.CancelFrom,
			&i.Subscription.CreatedAt,
			&i.Subscription.UpdatedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInternalSubscriptions = `-- name: UpdateInternalSubscriptions :exec
UPDATE backend.subscriptions
SET status = $1, updated_at = NOW()
WHERE
  source = 'internal' AND
  trial_ends_at IS NOT NULL AND
  trial_ends_at BETWEEN $2 AND $3 AND
  status = $4 AND
  next_billed_at IS NULL
`

type UpdateInternalSubscriptionsParams struct {
	Status        string             `db:"status" json:"status"`
	TrialEndsAt   pgtype.Timestamptz `db:"trial_ends_at" json:"trial_ends_at"`
	TrialEndsAt_2 pgtype.Timestamptz `db:"trial_ends_at_2" json:"trial_ends_at_2"`
	Status_2      string             `db:"status_2" json:"status_2"`
}

func (q *Queries) UpdateInternalSubscriptions(ctx context.Context, arg *UpdateInternalSubscriptionsParams) error {
	_, err := q.db.Exec(ctx, updateInternalSubscriptions,
		arg.Status,
		arg.TrialEndsAt,
		arg.TrialEndsAt_2,
		arg.Status_2,
	)
	return err
}
