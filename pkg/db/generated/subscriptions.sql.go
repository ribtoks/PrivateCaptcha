// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: subscriptions.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO backend.subscriptions (external_product_id, external_price_id, external_subscription_id, external_customer_id, external_email, status, source, trial_ends_at, next_billed_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING id, external_product_id, external_price_id, external_subscription_id, external_customer_id, status, source, trial_ends_at, next_billed_at, cancel_from, created_at, updated_at, external_email
`

type CreateSubscriptionParams struct {
	ExternalProductID      string             `db:"external_product_id" json:"external_product_id"`
	ExternalPriceID        string             `db:"external_price_id" json:"external_price_id"`
	ExternalSubscriptionID pgtype.Text        `db:"external_subscription_id" json:"external_subscription_id"`
	ExternalCustomerID     pgtype.Text        `db:"external_customer_id" json:"external_customer_id"`
	ExternalEmail          pgtype.Text        `db:"external_email" json:"external_email"`
	Status                 string             `db:"status" json:"status"`
	Source                 SubscriptionSource `db:"source" json:"source"`
	TrialEndsAt            pgtype.Timestamptz `db:"trial_ends_at" json:"trial_ends_at"`
	NextBilledAt           pgtype.Timestamptz `db:"next_billed_at" json:"next_billed_at"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg *CreateSubscriptionParams) (*Subscription, error) {
	row := q.db.QueryRow(ctx, createSubscription,
		arg.ExternalProductID,
		arg.ExternalPriceID,
		arg.ExternalSubscriptionID,
		arg.ExternalCustomerID,
		arg.ExternalEmail,
		arg.Status,
		arg.Source,
		arg.TrialEndsAt,
		arg.NextBilledAt,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.ExternalProductID,
		&i.ExternalPriceID,
		&i.ExternalSubscriptionID,
		&i.ExternalCustomerID,
		&i.Status,
		&i.Source,
		&i.TrialEndsAt,
		&i.NextBilledAt,
		&i.CancelFrom,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExternalEmail,
	)
	return &i, err
}

const getSubscriptionByID = `-- name: GetSubscriptionByID :one
SELECT id, external_product_id, external_price_id, external_subscription_id, external_customer_id, status, source, trial_ends_at, next_billed_at, cancel_from, created_at, updated_at, external_email FROM backend.subscriptions WHERE id = $1
`

func (q *Queries) GetSubscriptionByID(ctx context.Context, id int32) (*Subscription, error) {
	row := q.db.QueryRow(ctx, getSubscriptionByID, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.ExternalProductID,
		&i.ExternalPriceID,
		&i.ExternalSubscriptionID,
		&i.ExternalCustomerID,
		&i.Status,
		&i.Source,
		&i.TrialEndsAt,
		&i.NextBilledAt,
		&i.CancelFrom,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExternalEmail,
	)
	return &i, err
}

const updateInternalSubscriptions = `-- name: UpdateInternalSubscriptions :exec
UPDATE backend.subscriptions
SET status = $1, updated_at = NOW()
WHERE
  source = 'internal' AND
  trial_ends_at IS NOT NULL AND
  trial_ends_at BETWEEN $2 AND $3 AND
  status = $4 AND
  next_billed_at IS NULL
`

type UpdateInternalSubscriptionsParams struct {
	Status        string             `db:"status" json:"status"`
	TrialEndsAt   pgtype.Timestamptz `db:"trial_ends_at" json:"trial_ends_at"`
	TrialEndsAt_2 pgtype.Timestamptz `db:"trial_ends_at_2" json:"trial_ends_at_2"`
	Status_2      string             `db:"status_2" json:"status_2"`
}

func (q *Queries) UpdateInternalSubscriptions(ctx context.Context, arg *UpdateInternalSubscriptionsParams) error {
	_, err := q.db.Exec(ctx, updateInternalSubscriptions,
		arg.Status,
		arg.TrialEndsAt,
		arg.TrialEndsAt_2,
		arg.Status_2,
	)
	return err
}
