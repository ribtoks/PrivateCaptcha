// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: locks.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteLock = `-- name: DeleteLock :exec
DELETE FROM backend.locks WHERE name = $1
`

func (q *Queries) DeleteLock(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, deleteLock, name)
	return err
}

const getLock = `-- name: GetLock :one
SELECT name, data, expires_at FROM backend.locks WHERE name = $1
`

func (q *Queries) GetLock(ctx context.Context, name string) (*Lock, error) {
	row := q.db.QueryRow(ctx, getLock, name)
	var i Lock
	err := row.Scan(&i.Name, &i.Data, &i.ExpiresAt)
	return &i, err
}

const insertLock = `-- name: InsertLock :one
INSERT INTO backend.locks (name, data, expires_at)
VALUES ($1, $2, $3)
ON CONFLICT (name) DO UPDATE
SET expires_at = EXCLUDED.expires_at
WHERE locks.expires_at <= NOW()
RETURNING name, data, expires_at
`

type InsertLockParams struct {
	Name      string             `db:"name" json:"name"`
	Data      []byte             `db:"data" json:"data"`
	ExpiresAt pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
}

func (q *Queries) InsertLock(ctx context.Context, arg *InsertLockParams) (*Lock, error) {
	row := q.db.QueryRow(ctx, insertLock, arg.Name, arg.Data, arg.ExpiresAt)
	var i Lock
	err := row.Scan(&i.Name, &i.Data, &i.ExpiresAt)
	return &i, err
}
