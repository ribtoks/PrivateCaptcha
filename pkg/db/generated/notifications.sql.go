// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: notifications.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createNotificationTemplate = `-- name: CreateNotificationTemplate :one
INSERT INTO backend.notification_templates (name, content_html, content_text, external_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT (external_id) DO UPDATE SET updated_at = NOW()
RETURNING id, name, external_id, content_html, content_text, created_at, updated_at
`

type CreateNotificationTemplateParams struct {
	Name        string `db:"name" json:"name"`
	ContentHtml string `db:"content_html" json:"content_html"`
	ContentText string `db:"content_text" json:"content_text"`
	ExternalID  string `db:"external_id" json:"external_id"`
}

func (q *Queries) CreateNotificationTemplate(ctx context.Context, arg *CreateNotificationTemplateParams) (*NotificationTemplate, error) {
	row := q.db.QueryRow(ctx, createNotificationTemplate,
		arg.Name,
		arg.ContentHtml,
		arg.ContentText,
		arg.ExternalID,
	)
	var i NotificationTemplate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ExternalID,
		&i.ContentHtml,
		&i.ContentText,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createSystemNotification = `-- name: CreateSystemNotification :one
INSERT INTO backend.system_notifications (message, start_date, end_date, user_id)
VALUES ($1, $2, $3, $4)
RETURNING id, message, start_date, end_date, user_id, is_active
`

type CreateSystemNotificationParams struct {
	Message   string             `db:"message" json:"message"`
	StartDate pgtype.Timestamptz `db:"start_date" json:"start_date"`
	EndDate   pgtype.Timestamptz `db:"end_date" json:"end_date"`
	UserID    pgtype.Int4        `db:"user_id" json:"user_id"`
}

func (q *Queries) CreateSystemNotification(ctx context.Context, arg *CreateSystemNotificationParams) (*SystemNotification, error) {
	row := q.db.QueryRow(ctx, createSystemNotification,
		arg.Message,
		arg.StartDate,
		arg.EndDate,
		arg.UserID,
	)
	var i SystemNotification
	err := row.Scan(
		&i.ID,
		&i.Message,
		&i.StartDate,
		&i.EndDate,
		&i.UserID,
		&i.IsActive,
	)
	return &i, err
}

const createUserNotification = `-- name: CreateUserNotification :one
INSERT INTO backend.user_notifications (user_id, reference_id, template_id, subject, payload, scheduled_at, persistent, requires_subscription)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, user_id, template_id, payload, subject, reference_id, processing_attempts, persistent, requires_subscription, created_at, updated_at, scheduled_at, processed_at
`

type CreateUserNotificationParams struct {
	UserID               pgtype.Int4        `db:"user_id" json:"user_id"`
	ReferenceID          string             `db:"reference_id" json:"reference_id"`
	TemplateID           pgtype.Text        `db:"template_id" json:"template_id"`
	Subject              string             `db:"subject" json:"subject"`
	Payload              []byte             `db:"payload" json:"payload"`
	ScheduledAt          pgtype.Timestamptz `db:"scheduled_at" json:"scheduled_at"`
	Persistent           bool               `db:"persistent" json:"persistent"`
	RequiresSubscription pgtype.Bool        `db:"requires_subscription" json:"requires_subscription"`
}

func (q *Queries) CreateUserNotification(ctx context.Context, arg *CreateUserNotificationParams) (*UserNotification, error) {
	row := q.db.QueryRow(ctx, createUserNotification,
		arg.UserID,
		arg.ReferenceID,
		arg.TemplateID,
		arg.Subject,
		arg.Payload,
		arg.ScheduledAt,
		arg.Persistent,
		arg.RequiresSubscription,
	)
	var i UserNotification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TemplateID,
		&i.Payload,
		&i.Subject,
		&i.ReferenceID,
		&i.ProcessingAttempts,
		&i.Persistent,
		&i.RequiresSubscription,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScheduledAt,
		&i.ProcessedAt,
	)
	return &i, err
}

const deletePendingUserNotification = `-- name: DeletePendingUserNotification :exec
DELETE FROM backend.user_notifications WHERE processed_at IS NULL AND user_id = $1 AND reference_id = $2
`

type DeletePendingUserNotificationParams struct {
	UserID      pgtype.Int4 `db:"user_id" json:"user_id"`
	ReferenceID string      `db:"reference_id" json:"reference_id"`
}

func (q *Queries) DeletePendingUserNotification(ctx context.Context, arg *DeletePendingUserNotificationParams) error {
	_, err := q.db.Exec(ctx, deletePendingUserNotification, arg.UserID, arg.ReferenceID)
	return err
}

const deleteProcessedUserNotifications = `-- name: DeleteProcessedUserNotifications :exec
DELETE FROM backend.user_notifications
WHERE processed_at IS NOT NULL
AND persistent = false
AND processed_at < $1
`

func (q *Queries) DeleteProcessedUserNotifications(ctx context.Context, processedAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteProcessedUserNotifications, processedAt)
	return err
}

const deleteUnprocessedUserNotifications = `-- name: DeleteUnprocessedUserNotifications :exec
DELETE FROM backend.user_notifications
WHERE processed_at IS NULL
AND persistent = false
AND scheduled_at < $1
`

func (q *Queries) DeleteUnprocessedUserNotifications(ctx context.Context, scheduledAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteUnprocessedUserNotifications, scheduledAt)
	return err
}

const deleteUnusedNotificationTemplates = `-- name: DeleteUnusedNotificationTemplates :exec
DELETE FROM backend.notification_templates nt
WHERE nt.id IN (
    SELECT nt2.id
    FROM backend.notification_templates nt2
    LEFT JOIN backend.user_notifications un ON un.template_id = nt2.external_id
    WHERE ((un.template_id IS NULL) OR (un.processed_at < $1))
    AND (nt2.updated_at < $2)
)
`

type DeleteUnusedNotificationTemplatesParams struct {
	ProcessedAt pgtype.Timestamptz `db:"processed_at" json:"processed_at"`
	UpdatedAt   pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) DeleteUnusedNotificationTemplates(ctx context.Context, arg *DeleteUnusedNotificationTemplatesParams) error {
	_, err := q.db.Exec(ctx, deleteUnusedNotificationTemplates, arg.ProcessedAt, arg.UpdatedAt)
	return err
}

const getLastActiveSystemNotification = `-- name: GetLastActiveSystemNotification :one
SELECT id, message, start_date, end_date, user_id, is_active FROM backend.system_notifications
 WHERE is_active = TRUE AND
   start_date <= $1::timestamptz AND
   (end_date IS NULL OR end_date > $1::timestamptz) AND
   (user_id = $2 OR user_id IS NULL)
 ORDER BY
   CASE WHEN user_id = $2 THEN 0 ELSE 1 END,
   start_date DESC
 LIMIT 1
`

type GetLastActiveSystemNotificationParams struct {
	Column1 pgtype.Timestamptz `db:"column_1" json:"column_1"`
	UserID  pgtype.Int4        `db:"user_id" json:"user_id"`
}

func (q *Queries) GetLastActiveSystemNotification(ctx context.Context, arg *GetLastActiveSystemNotificationParams) (*SystemNotification, error) {
	row := q.db.QueryRow(ctx, getLastActiveSystemNotification, arg.Column1, arg.UserID)
	var i SystemNotification
	err := row.Scan(
		&i.ID,
		&i.Message,
		&i.StartDate,
		&i.EndDate,
		&i.UserID,
		&i.IsActive,
	)
	return &i, err
}

const getNotificationTemplateByHash = `-- name: GetNotificationTemplateByHash :one
SELECT id, name, external_id, content_html, content_text, created_at, updated_at FROM backend.notification_templates WHERE external_id = $1
`

func (q *Queries) GetNotificationTemplateByHash(ctx context.Context, externalID string) (*NotificationTemplate, error) {
	row := q.db.QueryRow(ctx, getNotificationTemplateByHash, externalID)
	var i NotificationTemplate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ExternalID,
		&i.ContentHtml,
		&i.ContentText,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getPendingUserNotifications = `-- name: GetPendingUserNotifications :many
SELECT un.id, un.user_id, un.template_id, un.payload, un.subject, un.reference_id, un.processing_attempts, un.persistent, un.requires_subscription, un.created_at, un.updated_at, un.scheduled_at, un.processed_at, u.email, u.subscription_id, s.status
FROM backend.user_notifications un
JOIN backend.users u ON un.user_id = u.id
LEFT JOIN backend.subscriptions s ON u.subscription_id = s.id
WHERE un.processed_at IS NULL
  AND un.scheduled_at >= $1
  AND un.scheduled_at <= NOW()
  AND u.deleted_at IS NULL
  AND un.processing_attempts < $2
  AND (un.requires_subscription IS NULL OR u.subscription_id IS NOT NULL)
ORDER BY un.scheduled_at ASC
LIMIT $3
`

type GetPendingUserNotificationsParams struct {
	ScheduledAt        pgtype.Timestamptz `db:"scheduled_at" json:"scheduled_at"`
	ProcessingAttempts int32              `db:"processing_attempts" json:"processing_attempts"`
	Limit              int32              `db:"limit" json:"limit"`
}

type GetPendingUserNotificationsRow struct {
	UserNotification UserNotification `db:"user_notification" json:"user_notification"`
	Email            string           `db:"email" json:"email"`
	SubscriptionID   pgtype.Int4      `db:"subscription_id" json:"subscription_id"`
	Status           pgtype.Text      `db:"status" json:"status"`
}

func (q *Queries) GetPendingUserNotifications(ctx context.Context, arg *GetPendingUserNotificationsParams) ([]*GetPendingUserNotificationsRow, error) {
	rows, err := q.db.Query(ctx, getPendingUserNotifications, arg.ScheduledAt, arg.ProcessingAttempts, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetPendingUserNotificationsRow
	for rows.Next() {
		var i GetPendingUserNotificationsRow
		if err := rows.Scan(
			&i.UserNotification.ID,
			&i.UserNotification.UserID,
			&i.UserNotification.TemplateID,
			&i.UserNotification.Payload,
			&i.UserNotification.Subject,
			&i.UserNotification.ReferenceID,
			&i.UserNotification.ProcessingAttempts,
			&i.UserNotification.Persistent,
			&i.UserNotification.RequiresSubscription,
			&i.UserNotification.CreatedAt,
			&i.UserNotification.UpdatedAt,
			&i.UserNotification.ScheduledAt,
			&i.UserNotification.ProcessedAt,
			&i.Email,
			&i.SubscriptionID,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSystemNotificationById = `-- name: GetSystemNotificationById :one
SELECT id, message, start_date, end_date, user_id, is_active FROM backend.system_notifications WHERE id = $1
`

func (q *Queries) GetSystemNotificationById(ctx context.Context, id int32) (*SystemNotification, error) {
	row := q.db.QueryRow(ctx, getSystemNotificationById, id)
	var i SystemNotification
	err := row.Scan(
		&i.ID,
		&i.Message,
		&i.StartDate,
		&i.EndDate,
		&i.UserID,
		&i.IsActive,
	)
	return &i, err
}

const updateAttemptedUserNotifications = `-- name: UpdateAttemptedUserNotifications :exec
UPDATE backend.user_notifications SET
  processing_attempts = processing_attempts + 1,
  updated_at = NOW()
WHERE id = ANY($1::INT[])
`

func (q *Queries) UpdateAttemptedUserNotifications(ctx context.Context, dollar_1 []int32) error {
	_, err := q.db.Exec(ctx, updateAttemptedUserNotifications, dollar_1)
	return err
}

const updateProcessedUserNotifications = `-- name: UpdateProcessedUserNotifications :exec
UPDATE backend.user_notifications SET
  processed_at = $1,
  processing_attempts = processing_attempts + 1,
  updated_at = NOW()
WHERE id = ANY($2::INT[])
`

type UpdateProcessedUserNotificationsParams struct {
	ProcessedAt pgtype.Timestamptz `db:"processed_at" json:"processed_at"`
	Column2     []int32            `db:"column_2" json:"column_2"`
}

func (q *Queries) UpdateProcessedUserNotifications(ctx context.Context, arg *UpdateProcessedUserNotificationsParams) error {
	_, err := q.db.Exec(ctx, updateProcessedUserNotifications, arg.ProcessedAt, arg.Column2)
	return err
}
